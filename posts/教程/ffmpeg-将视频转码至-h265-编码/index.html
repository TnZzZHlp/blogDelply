<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ffmpeg 将视频转码至 h265 编码 | 明天吃什么？</title><meta name=keywords content="ffmpeg,h265,视频转码"><meta name=description content='ffmpeg 简介
FFmpeg是一个开源的音视频处理工具，支持录制、转换数字音频、视频，并能将其转化为流。它包含了一个完整的解决方案，能够处理几乎所有的音视频格式。
FFmpeg的核心是libavcodec库，它提供了多种音视频编解码器，支持从简单的音频转码到复杂的视频处理任务。FFmpeg还提供了丰富的命令行工具，用户可以通过命令行轻松实现音视频的转换、剪辑、合并等操作。
FFmpeg的跨平台特性使其能够在Linux、Windows和macOS等多种操作系统上运行。它的强大功能和灵活性使其成为音视频处理领域的事实标准。
Source
必要条件

安装FFmpeg：确保你的系统上已经安装了FFmpeg。

转码命令
# Intel QuickSync (hevc_qsv)
# 参数:
#   -global_quality: 1–51（类似 CRF，数值越大质量越低，文件越小，默认23）
#   -preset: ultrafast | fast | medium | slow | slower | veryslow（速度↑/压缩率↓，默认medium）
ffmpeg -y -i input.mp4 \
  -c:v hevc_qsv -global_quality 23 -preset medium \
  -c:a copy -c:s copy \
  output_h265_intel.mp4
# AMD AMF (hevc_amf)
# 参数:
#   -qp:       0–51（质量参数，数值越大压缩越强，默认23）
#   -quality:  speed | balanced | quality（speed=最快最低质；balanced=中；quality=最高质，默认balanced）
ffmpeg -y -i input.mp4 \
  -c:v hevc_amf -rc cqp -qp 23 -quality balanced \
  -c:a copy -c:s copy \
  output_h265_amd.mp4
# NVIDIA NVENC (hevc_nvenc)
# 参数:
#   -cq:     0–51（质量参数，数值越大质量越低，文件越小，默认23）
#   -preset: ultrafast | fast | medium | slow | slower | veryslow（同x265预设，默认medium）
ffmpeg -y -i input.mp4 \
  -c:v hevc_nvenc -cq 23 -preset medium \
  -c:a copy -c:s copy \
  output_h265_nvidia.mp4
# 软件 x265 (libx265)
# 参数:
#   -crf:    0–51（数值越大压缩越强，默认23）
#   -preset: ultrafast | fast | medium | slow | slower | veryslow（速度↑/压缩率↓，默认medium）
ffmpeg -y -i input.mp4 \
  -c:v libx265 -crf 23 -preset medium \
  -c:a copy -c:s copy \
  output_h265_x265.mp4
Python 脚本
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
将视频文件转码为H.265编码。
用法: python convert_to_h265.py <视频文件路径> [--intel] [--amd] [--nvidia]
使用 --intel 参数启用 Intel QuickSync 硬件加速
使用 --amd 参数启用 AMD AMF 硬件加速
使用 --nvidia 参数启用 NVIDIA NVENC 硬件加速
"""

import argparse
import os
import subprocess
import sys


def convert_to_h265(
    input_file,
    use_intel=False,
    use_amd=False,
    use_nvidia=False,
    crf=23,
    preset="medium",
    bitrate=None,
):
    """
    使用ffmpeg将视频转码为H.265格式

    参数:
        input_file: 输入视频文件路径
        use_intel: 是否使用Intel QuickSync硬件加速
        use_amd: 是否使用AMD AMF硬件加速
        use_nvidia: 是否使用NVIDIA NVENC硬件加速
    """
    # 检查文件是否存在
    if not os.path.isfile(input_file):
        print(f"错误: 文件不存在 - {input_file}")
        return False

    # 构建输出文件路径
    file_dir = os.path.dirname(input_file)
    file_name, file_ext = os.path.splitext(os.path.basename(input_file))
    output_file = os.path.join(file_dir, f"{file_name}_h265{file_ext}")

    # 将 Windows 路径反斜杠改为正斜杠，避免 \0 被误识别
    input_file = input_file.replace("\\", "/")
    output_file = output_file.replace("\\", "/")

    # 构建 ffmpeg 命令
    ffmpeg_cmd = [
        "ffmpeg",
        "-y",  # 如果目标已存在则强制覆盖
        "-i",
        input_file,
    ]

    # 硬件／软件编码选择
    if use_intel:
        ffmpeg_cmd.extend(
            [
                "-c:v",
                "hevc_qsv",  # Intel QuickSync HEVC/H.265编码器
                "-global_quality",
                str(crf),  # QSV 对应的质量参数
                "-preset",
                preset,
            ]
        )
    elif use_amd:
        # 将 --preset 映射到 AMF 的 quality 参数
        amf_quality = {
            "ultrafast": "speed",
            "fast": "speed",
            "medium": "balanced",
            "slow": "quality",
            "slower": "quality",
            "veryslow": "quality",
        }.get(preset, "balanced")

        ffmpeg_cmd.extend(
            [
                "-c:v",
                "hevc_amf",  # AMD HEVC/H.265编码器
                "-rc",
                "cqp",  # AMF 使用 CQP 模式
                "-qp",
                str(crf),  # AMF 的质量参数
                "-quality",
                amf_quality,  # AMF 支持的 quality 选项
            ]
        )
    elif use_nvidia:
        ffmpeg_cmd.extend(
            [
                "-c:v",
                "hevc_nvenc",  # NVIDIA NVENC H.265编码器
                "-cq",
                str(crf),  # NVENC 的质量参数
                "-preset",
                preset,
            ]
        )
    else:
        # 软件 x265 编码
        ffmpeg_cmd.extend(
            [
                "-c:v",
                "libx265",  # 软件x265编码器
                "-crf",
                str(crf),
                "-preset",
                preset,
            ]
        )

    # 如果指定了固定码率，则覆盖质量参数
    if bitrate:
        ffmpeg_cmd.extend(["-b:v", bitrate])

    # 添加通用的编码参数
    ffmpeg_cmd.extend(
        [
            "-c:a",
            "copy",  # 复制音频流
            "-c:s",
            "copy",  # 复制字幕流 (如果有)
            output_file,
        ]
    )

    print(f"正在转码: {input_file}")
    print(f"输出文件: {output_file}")
    print("转码中，请稍候...")

    try:

        # 执行ffmpeg命令
        process = subprocess.Popen(
            ffmpeg_cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            universal_newlines=True,
        )

        # 安全地处理并显示进度信息
        if process.stdout:  # 确保stdout不是None
            for line in process.stdout:
                # 仅显示包含关键字的行以减少输出量
                if "frame=" in line or "speed=" in line or "error" in line.lower():
                    print(f"\r{line.strip()}", end="")
        else:
            # 如果无法获取输出流，提供一个替代方案
            print("正在处理中，请等待...")

        # 等待进程完成
        return_code = process.wait()

        if return_code == 0:
            print(f"\n\n转码完成！输出文件: {output_file}")
            print(f"原始文件大小: {os.path.getsize(input_file) / (1024*1024):.2f} MB")
            print(
                f"转码后文件大小: {os.path.getsize(output_file) / (1024*1024):.2f} MB"
            )
            return True
        else:
            print(f"\n转码失败，ffmpeg返回错误代码: {return_code}")
            return False

    except FileNotFoundError:
        print("错误: 找不到ffmpeg。请确保ffmpeg已安装并添加到系统PATH中。")
        return False
    except Exception as e:
        print(f"发生错误: {str(e)}")
        return False


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="将视频转码为H.265格式")
    parser.add_argument("input_file", help="输入视频文件路径")
    parser.add_argument(
        "--intel",
        action="store_true",
        help="使用 Intel QuickSync硬件加速",
    )
    parser.add_argument(
        "--amd",
        action="store_true",
        help="使用 AMD GPU 硬件加速",
    )
    parser.add_argument(
        "--nvidia",
        action="store_true",
        help="使用 NVIDIA NVENC 硬件加速",
    )

    # 新增质量/码率可调参数
    parser.add_argument(
        "--crf",
        type=int,
        default=23,
        help="质量参数（CRF或等效值，数值越大文件越小）",
    )
    parser.add_argument(
        "--preset",
        default="medium",
        choices=[
            "ultrafast",
            "fast",
            "medium",
            "slow",
            "slower",
            "veryslow",
        ],
        help="编码preset",
    )
    parser.add_argument(
        "--bitrate",
        help="目标码率，如2000k，优先于CRF/质量参数",
    )

    args = parser.parse_args()
    if sum(bool(x) for x in (args.intel, args.amd, args.nvidia)) > 1:
        print("错误: 只能指定一个硬件加速选项")
        sys.exit(1)

    convert_to_h265(
        args.input_file,
        use_intel=args.intel,
        use_amd=args.amd,
        use_nvidia=args.nvidia,
        crf=args.crf,
        preset=args.preset,
        bitrate=args.bitrate,
    )
'><meta name=author content><link rel=canonical href=https://tnzzz.top/posts/%E6%95%99%E7%A8%8B/ffmpeg-%E5%B0%86%E8%A7%86%E9%A2%91%E8%BD%AC%E7%A0%81%E8%87%B3-h265-%E7%BC%96%E7%A0%81/><link crossorigin=anonymous href=/assets/css/stylesheet.93f625d739f1d6a5c6f20c146bc6a8d26b233492b34b2220c54b12fd46a04ded.css integrity="sha256-k/Yl1znx1qXG8gwUa8ao0msjNJKzSyIgxUsS/UagTe0=" rel="preload stylesheet" as=style><link rel=icon href=https://tnzzz.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tnzzz.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tnzzz.top/favicon-32x32.png><link rel=apple-touch-icon href=https://tnzzz.top/apple-touch-icon.png><link rel=mask-icon href=https://tnzzz.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://tnzzz.top/posts/%E6%95%99%E7%A8%8B/ffmpeg-%E5%B0%86%E8%A7%86%E9%A2%91%E8%BD%AC%E7%A0%81%E8%87%B3-h265-%E7%BC%96%E7%A0%81/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://tnzzz.top/posts/%E6%95%99%E7%A8%8B/ffmpeg-%E5%B0%86%E8%A7%86%E9%A2%91%E8%BD%AC%E7%A0%81%E8%87%B3-h265-%E7%BC%96%E7%A0%81/"><meta property="og:site_name" content="明天吃什么？"><meta property="og:title" content="ffmpeg 将视频转码至 h265 编码"><meta property="og:description" content='ffmpeg 简介 FFmpeg是一个开源的音视频处理工具，支持录制、转换数字音频、视频，并能将其转化为流。它包含了一个完整的解决方案，能够处理几乎所有的音视频格式。
FFmpeg的核心是libavcodec库，它提供了多种音视频编解码器，支持从简单的音频转码到复杂的视频处理任务。FFmpeg还提供了丰富的命令行工具，用户可以通过命令行轻松实现音视频的转换、剪辑、合并等操作。
FFmpeg的跨平台特性使其能够在Linux、Windows和macOS等多种操作系统上运行。它的强大功能和灵活性使其成为音视频处理领域的事实标准。
Source
必要条件 安装FFmpeg：确保你的系统上已经安装了FFmpeg。 转码命令 # Intel QuickSync (hevc_qsv) # 参数: # -global_quality: 1–51（类似 CRF，数值越大质量越低，文件越小，默认23） # -preset: ultrafast | fast | medium | slow | slower | veryslow（速度↑/压缩率↓，默认medium） ffmpeg -y -i input.mp4 \ -c:v hevc_qsv -global_quality 23 -preset medium \ -c:a copy -c:s copy \ output_h265_intel.mp4 # AMD AMF (hevc_amf) # 参数: # -qp: 0–51（质量参数，数值越大压缩越强，默认23） # -quality: speed | balanced | quality（speed=最快最低质；balanced=中；quality=最高质，默认balanced） ffmpeg -y -i input.mp4 \ -c:v hevc_amf -rc cqp -qp 23 -quality balanced \ -c:a copy -c:s copy \ output_h265_amd.mp4 # NVIDIA NVENC (hevc_nvenc) # 参数: # -cq: 0–51（质量参数，数值越大质量越低，文件越小，默认23） # -preset: ultrafast | fast | medium | slow | slower | veryslow（同x265预设，默认medium） ffmpeg -y -i input.mp4 \ -c:v hevc_nvenc -cq 23 -preset medium \ -c:a copy -c:s copy \ output_h265_nvidia.mp4 # 软件 x265 (libx265) # 参数: # -crf: 0–51（数值越大压缩越强，默认23） # -preset: ultrafast | fast | medium | slow | slower | veryslow（速度↑/压缩率↓，默认medium） ffmpeg -y -i input.mp4 \ -c:v libx265 -crf 23 -preset medium \ -c:a copy -c:s copy \ output_h265_x265.mp4 Python 脚本 #!/usr/bin/env python3 # -*- coding: utf-8 -*- """ 将视频文件转码为H.265编码。 用法: python convert_to_h265.py <视频文件路径> [--intel] [--amd] [--nvidia] 使用 --intel 参数启用 Intel QuickSync 硬件加速 使用 --amd 参数启用 AMD AMF 硬件加速 使用 --nvidia 参数启用 NVIDIA NVENC 硬件加速 """ import argparse import os import subprocess import sys def convert_to_h265( input_file, use_intel=False, use_amd=False, use_nvidia=False, crf=23, preset="medium", bitrate=None, ): """ 使用ffmpeg将视频转码为H.265格式 参数: input_file: 输入视频文件路径 use_intel: 是否使用Intel QuickSync硬件加速 use_amd: 是否使用AMD AMF硬件加速 use_nvidia: 是否使用NVIDIA NVENC硬件加速 """ # 检查文件是否存在 if not os.path.isfile(input_file): print(f"错误: 文件不存在 - {input_file}") return False # 构建输出文件路径 file_dir = os.path.dirname(input_file) file_name, file_ext = os.path.splitext(os.path.basename(input_file)) output_file = os.path.join(file_dir, f"{file_name}_h265{file_ext}") # 将 Windows 路径反斜杠改为正斜杠，避免 \0 被误识别 input_file = input_file.replace("\\", "/") output_file = output_file.replace("\\", "/") # 构建 ffmpeg 命令 ffmpeg_cmd = [ "ffmpeg", "-y", # 如果目标已存在则强制覆盖 "-i", input_file, ] # 硬件／软件编码选择 if use_intel: ffmpeg_cmd.extend( [ "-c:v", "hevc_qsv", # Intel QuickSync HEVC/H.265编码器 "-global_quality", str(crf), # QSV 对应的质量参数 "-preset", preset, ] ) elif use_amd: # 将 --preset 映射到 AMF 的 quality 参数 amf_quality = { "ultrafast": "speed", "fast": "speed", "medium": "balanced", "slow": "quality", "slower": "quality", "veryslow": "quality", }.get(preset, "balanced") ffmpeg_cmd.extend( [ "-c:v", "hevc_amf", # AMD HEVC/H.265编码器 "-rc", "cqp", # AMF 使用 CQP 模式 "-qp", str(crf), # AMF 的质量参数 "-quality", amf_quality, # AMF 支持的 quality 选项 ] ) elif use_nvidia: ffmpeg_cmd.extend( [ "-c:v", "hevc_nvenc", # NVIDIA NVENC H.265编码器 "-cq", str(crf), # NVENC 的质量参数 "-preset", preset, ] ) else: # 软件 x265 编码 ffmpeg_cmd.extend( [ "-c:v", "libx265", # 软件x265编码器 "-crf", str(crf), "-preset", preset, ] ) # 如果指定了固定码率，则覆盖质量参数 if bitrate: ffmpeg_cmd.extend(["-b:v", bitrate]) # 添加通用的编码参数 ffmpeg_cmd.extend( [ "-c:a", "copy", # 复制音频流 "-c:s", "copy", # 复制字幕流 (如果有) output_file, ] ) print(f"正在转码: {input_file}") print(f"输出文件: {output_file}") print("转码中，请稍候...") try: # 执行ffmpeg命令 process = subprocess.Popen( ffmpeg_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True, ) # 安全地处理并显示进度信息 if process.stdout: # 确保stdout不是None for line in process.stdout: # 仅显示包含关键字的行以减少输出量 if "frame=" in line or "speed=" in line or "error" in line.lower(): print(f"\r{line.strip()}", end="") else: # 如果无法获取输出流，提供一个替代方案 print("正在处理中，请等待...") # 等待进程完成 return_code = process.wait() if return_code == 0: print(f"\n\n转码完成！输出文件: {output_file}") print(f"原始文件大小: {os.path.getsize(input_file) / (1024*1024):.2f} MB") print( f"转码后文件大小: {os.path.getsize(output_file) / (1024*1024):.2f} MB" ) return True else: print(f"\n转码失败，ffmpeg返回错误代码: {return_code}") return False except FileNotFoundError: print("错误: 找不到ffmpeg。请确保ffmpeg已安装并添加到系统PATH中。") return False except Exception as e: print(f"发生错误: {str(e)}") return False if __name__ == "__main__": parser = argparse.ArgumentParser(description="将视频转码为H.265格式") parser.add_argument("input_file", help="输入视频文件路径") parser.add_argument( "--intel", action="store_true", help="使用 Intel QuickSync硬件加速", ) parser.add_argument( "--amd", action="store_true", help="使用 AMD GPU 硬件加速", ) parser.add_argument( "--nvidia", action="store_true", help="使用 NVIDIA NVENC 硬件加速", ) # 新增质量/码率可调参数 parser.add_argument( "--crf", type=int, default=23, help="质量参数（CRF或等效值，数值越大文件越小）", ) parser.add_argument( "--preset", default="medium", choices=[ "ultrafast", "fast", "medium", "slow", "slower", "veryslow", ], help="编码preset", ) parser.add_argument( "--bitrate", help="目标码率，如2000k，优先于CRF/质量参数", ) args = parser.parse_args() if sum(bool(x) for x in (args.intel, args.amd, args.nvidia)) > 1: print("错误: 只能指定一个硬件加速选项") sys.exit(1) convert_to_h265( args.input_file, use_intel=args.intel, use_amd=args.amd, use_nvidia=args.nvidia, crf=args.crf, preset=args.preset, bitrate=args.bitrate, ) '><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-20T22:17:40+08:00"><meta property="article:modified_time" content="2025-05-20T22:17:40+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="ffmpeg 将视频转码至 h265 编码"><meta name=twitter:description content='ffmpeg 简介
FFmpeg是一个开源的音视频处理工具，支持录制、转换数字音频、视频，并能将其转化为流。它包含了一个完整的解决方案，能够处理几乎所有的音视频格式。
FFmpeg的核心是libavcodec库，它提供了多种音视频编解码器，支持从简单的音频转码到复杂的视频处理任务。FFmpeg还提供了丰富的命令行工具，用户可以通过命令行轻松实现音视频的转换、剪辑、合并等操作。
FFmpeg的跨平台特性使其能够在Linux、Windows和macOS等多种操作系统上运行。它的强大功能和灵活性使其成为音视频处理领域的事实标准。
Source
必要条件

安装FFmpeg：确保你的系统上已经安装了FFmpeg。

转码命令
# Intel QuickSync (hevc_qsv)
# 参数:
#   -global_quality: 1–51（类似 CRF，数值越大质量越低，文件越小，默认23）
#   -preset: ultrafast | fast | medium | slow | slower | veryslow（速度↑/压缩率↓，默认medium）
ffmpeg -y -i input.mp4 \
  -c:v hevc_qsv -global_quality 23 -preset medium \
  -c:a copy -c:s copy \
  output_h265_intel.mp4
# AMD AMF (hevc_amf)
# 参数:
#   -qp:       0–51（质量参数，数值越大压缩越强，默认23）
#   -quality:  speed | balanced | quality（speed=最快最低质；balanced=中；quality=最高质，默认balanced）
ffmpeg -y -i input.mp4 \
  -c:v hevc_amf -rc cqp -qp 23 -quality balanced \
  -c:a copy -c:s copy \
  output_h265_amd.mp4
# NVIDIA NVENC (hevc_nvenc)
# 参数:
#   -cq:     0–51（质量参数，数值越大质量越低，文件越小，默认23）
#   -preset: ultrafast | fast | medium | slow | slower | veryslow（同x265预设，默认medium）
ffmpeg -y -i input.mp4 \
  -c:v hevc_nvenc -cq 23 -preset medium \
  -c:a copy -c:s copy \
  output_h265_nvidia.mp4
# 软件 x265 (libx265)
# 参数:
#   -crf:    0–51（数值越大压缩越强，默认23）
#   -preset: ultrafast | fast | medium | slow | slower | veryslow（速度↑/压缩率↓，默认medium）
ffmpeg -y -i input.mp4 \
  -c:v libx265 -crf 23 -preset medium \
  -c:a copy -c:s copy \
  output_h265_x265.mp4
Python 脚本
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
将视频文件转码为H.265编码。
用法: python convert_to_h265.py <视频文件路径> [--intel] [--amd] [--nvidia]
使用 --intel 参数启用 Intel QuickSync 硬件加速
使用 --amd 参数启用 AMD AMF 硬件加速
使用 --nvidia 参数启用 NVIDIA NVENC 硬件加速
"""

import argparse
import os
import subprocess
import sys


def convert_to_h265(
    input_file,
    use_intel=False,
    use_amd=False,
    use_nvidia=False,
    crf=23,
    preset="medium",
    bitrate=None,
):
    """
    使用ffmpeg将视频转码为H.265格式

    参数:
        input_file: 输入视频文件路径
        use_intel: 是否使用Intel QuickSync硬件加速
        use_amd: 是否使用AMD AMF硬件加速
        use_nvidia: 是否使用NVIDIA NVENC硬件加速
    """
    # 检查文件是否存在
    if not os.path.isfile(input_file):
        print(f"错误: 文件不存在 - {input_file}")
        return False

    # 构建输出文件路径
    file_dir = os.path.dirname(input_file)
    file_name, file_ext = os.path.splitext(os.path.basename(input_file))
    output_file = os.path.join(file_dir, f"{file_name}_h265{file_ext}")

    # 将 Windows 路径反斜杠改为正斜杠，避免 \0 被误识别
    input_file = input_file.replace("\\", "/")
    output_file = output_file.replace("\\", "/")

    # 构建 ffmpeg 命令
    ffmpeg_cmd = [
        "ffmpeg",
        "-y",  # 如果目标已存在则强制覆盖
        "-i",
        input_file,
    ]

    # 硬件／软件编码选择
    if use_intel:
        ffmpeg_cmd.extend(
            [
                "-c:v",
                "hevc_qsv",  # Intel QuickSync HEVC/H.265编码器
                "-global_quality",
                str(crf),  # QSV 对应的质量参数
                "-preset",
                preset,
            ]
        )
    elif use_amd:
        # 将 --preset 映射到 AMF 的 quality 参数
        amf_quality = {
            "ultrafast": "speed",
            "fast": "speed",
            "medium": "balanced",
            "slow": "quality",
            "slower": "quality",
            "veryslow": "quality",
        }.get(preset, "balanced")

        ffmpeg_cmd.extend(
            [
                "-c:v",
                "hevc_amf",  # AMD HEVC/H.265编码器
                "-rc",
                "cqp",  # AMF 使用 CQP 模式
                "-qp",
                str(crf),  # AMF 的质量参数
                "-quality",
                amf_quality,  # AMF 支持的 quality 选项
            ]
        )
    elif use_nvidia:
        ffmpeg_cmd.extend(
            [
                "-c:v",
                "hevc_nvenc",  # NVIDIA NVENC H.265编码器
                "-cq",
                str(crf),  # NVENC 的质量参数
                "-preset",
                preset,
            ]
        )
    else:
        # 软件 x265 编码
        ffmpeg_cmd.extend(
            [
                "-c:v",
                "libx265",  # 软件x265编码器
                "-crf",
                str(crf),
                "-preset",
                preset,
            ]
        )

    # 如果指定了固定码率，则覆盖质量参数
    if bitrate:
        ffmpeg_cmd.extend(["-b:v", bitrate])

    # 添加通用的编码参数
    ffmpeg_cmd.extend(
        [
            "-c:a",
            "copy",  # 复制音频流
            "-c:s",
            "copy",  # 复制字幕流 (如果有)
            output_file,
        ]
    )

    print(f"正在转码: {input_file}")
    print(f"输出文件: {output_file}")
    print("转码中，请稍候...")

    try:

        # 执行ffmpeg命令
        process = subprocess.Popen(
            ffmpeg_cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            universal_newlines=True,
        )

        # 安全地处理并显示进度信息
        if process.stdout:  # 确保stdout不是None
            for line in process.stdout:
                # 仅显示包含关键字的行以减少输出量
                if "frame=" in line or "speed=" in line or "error" in line.lower():
                    print(f"\r{line.strip()}", end="")
        else:
            # 如果无法获取输出流，提供一个替代方案
            print("正在处理中，请等待...")

        # 等待进程完成
        return_code = process.wait()

        if return_code == 0:
            print(f"\n\n转码完成！输出文件: {output_file}")
            print(f"原始文件大小: {os.path.getsize(input_file) / (1024*1024):.2f} MB")
            print(
                f"转码后文件大小: {os.path.getsize(output_file) / (1024*1024):.2f} MB"
            )
            return True
        else:
            print(f"\n转码失败，ffmpeg返回错误代码: {return_code}")
            return False

    except FileNotFoundError:
        print("错误: 找不到ffmpeg。请确保ffmpeg已安装并添加到系统PATH中。")
        return False
    except Exception as e:
        print(f"发生错误: {str(e)}")
        return False


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="将视频转码为H.265格式")
    parser.add_argument("input_file", help="输入视频文件路径")
    parser.add_argument(
        "--intel",
        action="store_true",
        help="使用 Intel QuickSync硬件加速",
    )
    parser.add_argument(
        "--amd",
        action="store_true",
        help="使用 AMD GPU 硬件加速",
    )
    parser.add_argument(
        "--nvidia",
        action="store_true",
        help="使用 NVIDIA NVENC 硬件加速",
    )

    # 新增质量/码率可调参数
    parser.add_argument(
        "--crf",
        type=int,
        default=23,
        help="质量参数（CRF或等效值，数值越大文件越小）",
    )
    parser.add_argument(
        "--preset",
        default="medium",
        choices=[
            "ultrafast",
            "fast",
            "medium",
            "slow",
            "slower",
            "veryslow",
        ],
        help="编码preset",
    )
    parser.add_argument(
        "--bitrate",
        help="目标码率，如2000k，优先于CRF/质量参数",
    )

    args = parser.parse_args()
    if sum(bool(x) for x in (args.intel, args.amd, args.nvidia)) > 1:
        print("错误: 只能指定一个硬件加速选项")
        sys.exit(1)

    convert_to_h265(
        args.input_file,
        use_intel=args.intel,
        use_amd=args.amd,
        use_nvidia=args.nvidia,
        crf=args.crf,
        preset=args.preset,
        bitrate=args.bitrate,
    )
'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tnzzz.top/posts/"},{"@type":"ListItem","position":2,"name":"ffmpeg 将视频转码至 h265 编码","item":"https://tnzzz.top/posts/%E6%95%99%E7%A8%8B/ffmpeg-%E5%B0%86%E8%A7%86%E9%A2%91%E8%BD%AC%E7%A0%81%E8%87%B3-h265-%E7%BC%96%E7%A0%81/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ffmpeg 将视频转码至 h265 编码","name":"ffmpeg 将视频转码至 h265 编码","description":"ffmpeg 简介 FFmpeg是一个开源的音视频处理工具，支持录制、转换数字音频、视频，并能将其转化为流。它包含了一个完整的解决方案，能够处理几乎所有的音视频格式。\nFFmpeg的核心是libavcodec库，它提供了多种音视频编解码器，支持从简单的音频转码到复杂的视频处理任务。FFmpeg还提供了丰富的命令行工具，用户可以通过命令行轻松实现音视频的转换、剪辑、合并等操作。\nFFmpeg的跨平台特性使其能够在Linux、Windows和macOS等多种操作系统上运行。它的强大功能和灵活性使其成为音视频处理领域的事实标准。\nSource\n必要条件 安装FFmpeg：确保你的系统上已经安装了FFmpeg。 转码命令 # Intel QuickSync (hevc_qsv) # 参数: # -global_quality: 1–51（类似 CRF，数值越大质量越低，文件越小，默认23） # -preset: ultrafast | fast | medium | slow | slower | veryslow（速度↑/压缩率↓，默认medium） ffmpeg -y -i input.mp4 \\ -c:v hevc_qsv -global_quality 23 -preset medium \\ -c:a copy -c:s copy \\ output_h265_intel.mp4 # AMD AMF (hevc_amf) # 参数: # -qp: 0–51（质量参数，数值越大压缩越强，默认23） # -quality: speed | balanced | quality（speed=最快最低质；balanced=中；quality=最高质，默认balanced） ffmpeg -y -i input.mp4 \\ -c:v hevc_amf -rc cqp -qp 23 -quality balanced \\ -c:a copy -c:s copy \\ output_h265_amd.mp4 # NVIDIA NVENC (hevc_nvenc) # 参数: # -cq: 0–51（质量参数，数值越大质量越低，文件越小，默认23） # -preset: ultrafast | fast | medium | slow | slower | veryslow（同x265预设，默认medium） ffmpeg -y -i input.mp4 \\ -c:v hevc_nvenc -cq 23 -preset medium \\ -c:a copy -c:s copy \\ output_h265_nvidia.mp4 # 软件 x265 (libx265) # 参数: # -crf: 0–51（数值越大压缩越强，默认23） # -preset: ultrafast | fast | medium | slow | slower | veryslow（速度↑/压缩率↓，默认medium） ffmpeg -y -i input.mp4 \\ -c:v libx265 -crf 23 -preset medium \\ -c:a copy -c:s copy \\ output_h265_x265.mp4 Python 脚本 #!/usr/bin/env python3 # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34; 将视频文件转码为H.265编码。 用法: python convert_to_h265.py \u0026lt;视频文件路径\u0026gt; [--intel] [--amd] [--nvidia] 使用 --intel 参数启用 Intel QuickSync 硬件加速 使用 --amd 参数启用 AMD AMF 硬件加速 使用 --nvidia 参数启用 NVIDIA NVENC 硬件加速 \u0026#34;\u0026#34;\u0026#34; import argparse import os import subprocess import sys def convert_to_h265( input_file, use_intel=False, use_amd=False, use_nvidia=False, crf=23, preset=\u0026#34;medium\u0026#34;, bitrate=None, ): \u0026#34;\u0026#34;\u0026#34; 使用ffmpeg将视频转码为H.265格式 参数: input_file: 输入视频文件路径 use_intel: 是否使用Intel QuickSync硬件加速 use_amd: 是否使用AMD AMF硬件加速 use_nvidia: 是否使用NVIDIA NVENC硬件加速 \u0026#34;\u0026#34;\u0026#34; # 检查文件是否存在 if not os.path.isfile(input_file): print(f\u0026#34;错误: 文件不存在 - {input_file}\u0026#34;) return False # 构建输出文件路径 file_dir = os.path.dirname(input_file) file_name, file_ext = os.path.splitext(os.path.basename(input_file)) output_file = os.path.join(file_dir, f\u0026#34;{file_name}_h265{file_ext}\u0026#34;) # 将 Windows 路径反斜杠改为正斜杠，避免 \\0 被误识别 input_file = input_file.replace(\u0026#34;\\\\\u0026#34;, \u0026#34;/\u0026#34;) output_file = output_file.replace(\u0026#34;\\\\\u0026#34;, \u0026#34;/\u0026#34;) # 构建 ffmpeg 命令 ffmpeg_cmd = [ \u0026#34;ffmpeg\u0026#34;, \u0026#34;-y\u0026#34;, # 如果目标已存在则强制覆盖 \u0026#34;-i\u0026#34;, input_file, ] # 硬件／软件编码选择 if use_intel: ffmpeg_cmd.extend( [ \u0026#34;-c:v\u0026#34;, \u0026#34;hevc_qsv\u0026#34;, # Intel QuickSync HEVC/H.265编码器 \u0026#34;-global_quality\u0026#34;, str(crf), # QSV 对应的质量参数 \u0026#34;-preset\u0026#34;, preset, ] ) elif use_amd: # 将 --preset 映射到 AMF 的 quality 参数 amf_quality = { \u0026#34;ultrafast\u0026#34;: \u0026#34;speed\u0026#34;, \u0026#34;fast\u0026#34;: \u0026#34;speed\u0026#34;, \u0026#34;medium\u0026#34;: \u0026#34;balanced\u0026#34;, \u0026#34;slow\u0026#34;: \u0026#34;quality\u0026#34;, \u0026#34;slower\u0026#34;: \u0026#34;quality\u0026#34;, \u0026#34;veryslow\u0026#34;: \u0026#34;quality\u0026#34;, }.get(preset, \u0026#34;balanced\u0026#34;) ffmpeg_cmd.extend( [ \u0026#34;-c:v\u0026#34;, \u0026#34;hevc_amf\u0026#34;, # AMD HEVC/H.265编码器 \u0026#34;-rc\u0026#34;, \u0026#34;cqp\u0026#34;, # AMF 使用 CQP 模式 \u0026#34;-qp\u0026#34;, str(crf), # AMF 的质量参数 \u0026#34;-quality\u0026#34;, amf_quality, # AMF 支持的 quality 选项 ] ) elif use_nvidia: ffmpeg_cmd.extend( [ \u0026#34;-c:v\u0026#34;, \u0026#34;hevc_nvenc\u0026#34;, # NVIDIA NVENC H.265编码器 \u0026#34;-cq\u0026#34;, str(crf), # NVENC 的质量参数 \u0026#34;-preset\u0026#34;, preset, ] ) else: # 软件 x265 编码 ffmpeg_cmd.extend( [ \u0026#34;-c:v\u0026#34;, \u0026#34;libx265\u0026#34;, # 软件x265编码器 \u0026#34;-crf\u0026#34;, str(crf), \u0026#34;-preset\u0026#34;, preset, ] ) # 如果指定了固定码率，则覆盖质量参数 if bitrate: ffmpeg_cmd.extend([\u0026#34;-b:v\u0026#34;, bitrate]) # 添加通用的编码参数 ffmpeg_cmd.extend( [ \u0026#34;-c:a\u0026#34;, \u0026#34;copy\u0026#34;, # 复制音频流 \u0026#34;-c:s\u0026#34;, \u0026#34;copy\u0026#34;, # 复制字幕流 (如果有) output_file, ] ) print(f\u0026#34;正在转码: {input_file}\u0026#34;) print(f\u0026#34;输出文件: {output_file}\u0026#34;) print(\u0026#34;转码中，请稍候...\u0026#34;) try: # 执行ffmpeg命令 process = subprocess.Popen( ffmpeg_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True, ) # 安全地处理并显示进度信息 if process.stdout: # 确保stdout不是None for line in process.stdout: # 仅显示包含关键字的行以减少输出量 if \u0026#34;frame=\u0026#34; in line or \u0026#34;speed=\u0026#34; in line or \u0026#34;error\u0026#34; in line.lower(): print(f\u0026#34;\\r{line.strip()}\u0026#34;, end=\u0026#34;\u0026#34;) else: # 如果无法获取输出流，提供一个替代方案 print(\u0026#34;正在处理中，请等待...\u0026#34;) # 等待进程完成 return_code = process.wait() if return_code == 0: print(f\u0026#34;\\n\\n转码完成！输出文件: {output_file}\u0026#34;) print(f\u0026#34;原始文件大小: {os.path.getsize(input_file) / (1024*1024):.2f} MB\u0026#34;) print( f\u0026#34;转码后文件大小: {os.path.getsize(output_file) / (1024*1024):.2f} MB\u0026#34; ) return True else: print(f\u0026#34;\\n转码失败，ffmpeg返回错误代码: {return_code}\u0026#34;) return False except FileNotFoundError: print(\u0026#34;错误: 找不到ffmpeg。请确保ffmpeg已安装并添加到系统PATH中。\u0026#34;) return False except Exception as e: print(f\u0026#34;发生错误: {str(e)}\u0026#34;) return False if __name__ == \u0026#34;__main__\u0026#34;: parser = argparse.ArgumentParser(description=\u0026#34;将视频转码为H.265格式\u0026#34;) parser.add_argument(\u0026#34;input_file\u0026#34;, help=\u0026#34;输入视频文件路径\u0026#34;) parser.add_argument( \u0026#34;--intel\u0026#34;, action=\u0026#34;store_true\u0026#34;, help=\u0026#34;使用 Intel QuickSync硬件加速\u0026#34;, ) parser.add_argument( \u0026#34;--amd\u0026#34;, action=\u0026#34;store_true\u0026#34;, help=\u0026#34;使用 AMD GPU 硬件加速\u0026#34;, ) parser.add_argument( \u0026#34;--nvidia\u0026#34;, action=\u0026#34;store_true\u0026#34;, help=\u0026#34;使用 NVIDIA NVENC 硬件加速\u0026#34;, ) # 新增质量/码率可调参数 parser.add_argument( \u0026#34;--crf\u0026#34;, type=int, default=23, help=\u0026#34;质量参数（CRF或等效值，数值越大文件越小）\u0026#34;, ) parser.add_argument( \u0026#34;--preset\u0026#34;, default=\u0026#34;medium\u0026#34;, choices=[ \u0026#34;ultrafast\u0026#34;, \u0026#34;fast\u0026#34;, \u0026#34;medium\u0026#34;, \u0026#34;slow\u0026#34;, \u0026#34;slower\u0026#34;, \u0026#34;veryslow\u0026#34;, ], help=\u0026#34;编码preset\u0026#34;, ) parser.add_argument( \u0026#34;--bitrate\u0026#34;, help=\u0026#34;目标码率，如2000k，优先于CRF/质量参数\u0026#34;, ) args = parser.parse_args() if sum(bool(x) for x in (args.intel, args.amd, args.nvidia)) \u0026gt; 1: print(\u0026#34;错误: 只能指定一个硬件加速选项\u0026#34;) sys.exit(1) convert_to_h265( args.input_file, use_intel=args.intel, use_amd=args.amd, use_nvidia=args.nvidia, crf=args.crf, preset=args.preset, bitrate=args.bitrate, ) ","keywords":["ffmpeg","h265","视频转码"],"articleBody":"ffmpeg 简介 FFmpeg是一个开源的音视频处理工具，支持录制、转换数字音频、视频，并能将其转化为流。它包含了一个完整的解决方案，能够处理几乎所有的音视频格式。\nFFmpeg的核心是libavcodec库，它提供了多种音视频编解码器，支持从简单的音频转码到复杂的视频处理任务。FFmpeg还提供了丰富的命令行工具，用户可以通过命令行轻松实现音视频的转换、剪辑、合并等操作。\nFFmpeg的跨平台特性使其能够在Linux、Windows和macOS等多种操作系统上运行。它的强大功能和灵活性使其成为音视频处理领域的事实标准。\nSource\n必要条件 安装FFmpeg：确保你的系统上已经安装了FFmpeg。 转码命令 # Intel QuickSync (hevc_qsv) # 参数: # -global_quality: 1–51（类似 CRF，数值越大质量越低，文件越小，默认23） # -preset: ultrafast | fast | medium | slow | slower | veryslow（速度↑/压缩率↓，默认medium） ffmpeg -y -i input.mp4 \\ -c:v hevc_qsv -global_quality 23 -preset medium \\ -c:a copy -c:s copy \\ output_h265_intel.mp4 # AMD AMF (hevc_amf) # 参数: # -qp: 0–51（质量参数，数值越大压缩越强，默认23） # -quality: speed | balanced | quality（speed=最快最低质；balanced=中；quality=最高质，默认balanced） ffmpeg -y -i input.mp4 \\ -c:v hevc_amf -rc cqp -qp 23 -quality balanced \\ -c:a copy -c:s copy \\ output_h265_amd.mp4 # NVIDIA NVENC (hevc_nvenc) # 参数: # -cq: 0–51（质量参数，数值越大质量越低，文件越小，默认23） # -preset: ultrafast | fast | medium | slow | slower | veryslow（同x265预设，默认medium） ffmpeg -y -i input.mp4 \\ -c:v hevc_nvenc -cq 23 -preset medium \\ -c:a copy -c:s copy \\ output_h265_nvidia.mp4 # 软件 x265 (libx265) # 参数: # -crf: 0–51（数值越大压缩越强，默认23） # -preset: ultrafast | fast | medium | slow | slower | veryslow（速度↑/压缩率↓，默认medium） ffmpeg -y -i input.mp4 \\ -c:v libx265 -crf 23 -preset medium \\ -c:a copy -c:s copy \\ output_h265_x265.mp4 Python 脚本 #!/usr/bin/env python3 # -*- coding: utf-8 -*- \"\"\" 将视频文件转码为H.265编码。 用法: python convert_to_h265.py \u003c视频文件路径\u003e [--intel] [--amd] [--nvidia] 使用 --intel 参数启用 Intel QuickSync 硬件加速 使用 --amd 参数启用 AMD AMF 硬件加速 使用 --nvidia 参数启用 NVIDIA NVENC 硬件加速 \"\"\" import argparse import os import subprocess import sys def convert_to_h265( input_file, use_intel=False, use_amd=False, use_nvidia=False, crf=23, preset=\"medium\", bitrate=None, ): \"\"\" 使用ffmpeg将视频转码为H.265格式 参数: input_file: 输入视频文件路径 use_intel: 是否使用Intel QuickSync硬件加速 use_amd: 是否使用AMD AMF硬件加速 use_nvidia: 是否使用NVIDIA NVENC硬件加速 \"\"\" # 检查文件是否存在 if not os.path.isfile(input_file): print(f\"错误: 文件不存在 - {input_file}\") return False # 构建输出文件路径 file_dir = os.path.dirname(input_file) file_name, file_ext = os.path.splitext(os.path.basename(input_file)) output_file = os.path.join(file_dir, f\"{file_name}_h265{file_ext}\") # 将 Windows 路径反斜杠改为正斜杠，避免 \\0 被误识别 input_file = input_file.replace(\"\\\\\", \"/\") output_file = output_file.replace(\"\\\\\", \"/\") # 构建 ffmpeg 命令 ffmpeg_cmd = [ \"ffmpeg\", \"-y\", # 如果目标已存在则强制覆盖 \"-i\", input_file, ] # 硬件／软件编码选择 if use_intel: ffmpeg_cmd.extend( [ \"-c:v\", \"hevc_qsv\", # Intel QuickSync HEVC/H.265编码器 \"-global_quality\", str(crf), # QSV 对应的质量参数 \"-preset\", preset, ] ) elif use_amd: # 将 --preset 映射到 AMF 的 quality 参数 amf_quality = { \"ultrafast\": \"speed\", \"fast\": \"speed\", \"medium\": \"balanced\", \"slow\": \"quality\", \"slower\": \"quality\", \"veryslow\": \"quality\", }.get(preset, \"balanced\") ffmpeg_cmd.extend( [ \"-c:v\", \"hevc_amf\", # AMD HEVC/H.265编码器 \"-rc\", \"cqp\", # AMF 使用 CQP 模式 \"-qp\", str(crf), # AMF 的质量参数 \"-quality\", amf_quality, # AMF 支持的 quality 选项 ] ) elif use_nvidia: ffmpeg_cmd.extend( [ \"-c:v\", \"hevc_nvenc\", # NVIDIA NVENC H.265编码器 \"-cq\", str(crf), # NVENC 的质量参数 \"-preset\", preset, ] ) else: # 软件 x265 编码 ffmpeg_cmd.extend( [ \"-c:v\", \"libx265\", # 软件x265编码器 \"-crf\", str(crf), \"-preset\", preset, ] ) # 如果指定了固定码率，则覆盖质量参数 if bitrate: ffmpeg_cmd.extend([\"-b:v\", bitrate]) # 添加通用的编码参数 ffmpeg_cmd.extend( [ \"-c:a\", \"copy\", # 复制音频流 \"-c:s\", \"copy\", # 复制字幕流 (如果有) output_file, ] ) print(f\"正在转码: {input_file}\") print(f\"输出文件: {output_file}\") print(\"转码中，请稍候...\") try: # 执行ffmpeg命令 process = subprocess.Popen( ffmpeg_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True, ) # 安全地处理并显示进度信息 if process.stdout: # 确保stdout不是None for line in process.stdout: # 仅显示包含关键字的行以减少输出量 if \"frame=\" in line or \"speed=\" in line or \"error\" in line.lower(): print(f\"\\r{line.strip()}\", end=\"\") else: # 如果无法获取输出流，提供一个替代方案 print(\"正在处理中，请等待...\") # 等待进程完成 return_code = process.wait() if return_code == 0: print(f\"\\n\\n转码完成！输出文件: {output_file}\") print(f\"原始文件大小: {os.path.getsize(input_file) / (1024*1024):.2f} MB\") print( f\"转码后文件大小: {os.path.getsize(output_file) / (1024*1024):.2f} MB\" ) return True else: print(f\"\\n转码失败，ffmpeg返回错误代码: {return_code}\") return False except FileNotFoundError: print(\"错误: 找不到ffmpeg。请确保ffmpeg已安装并添加到系统PATH中。\") return False except Exception as e: print(f\"发生错误: {str(e)}\") return False if __name__ == \"__main__\": parser = argparse.ArgumentParser(description=\"将视频转码为H.265格式\") parser.add_argument(\"input_file\", help=\"输入视频文件路径\") parser.add_argument( \"--intel\", action=\"store_true\", help=\"使用 Intel QuickSync硬件加速\", ) parser.add_argument( \"--amd\", action=\"store_true\", help=\"使用 AMD GPU 硬件加速\", ) parser.add_argument( \"--nvidia\", action=\"store_true\", help=\"使用 NVIDIA NVENC 硬件加速\", ) # 新增质量/码率可调参数 parser.add_argument( \"--crf\", type=int, default=23, help=\"质量参数（CRF或等效值，数值越大文件越小）\", ) parser.add_argument( \"--preset\", default=\"medium\", choices=[ \"ultrafast\", \"fast\", \"medium\", \"slow\", \"slower\", \"veryslow\", ], help=\"编码preset\", ) parser.add_argument( \"--bitrate\", help=\"目标码率，如2000k，优先于CRF/质量参数\", ) args = parser.parse_args() if sum(bool(x) for x in (args.intel, args.amd, args.nvidia)) \u003e 1: print(\"错误: 只能指定一个硬件加速选项\") sys.exit(1) convert_to_h265( args.input_file, use_intel=args.intel, use_amd=args.amd, use_nvidia=args.nvidia, crf=args.crf, preset=args.preset, bitrate=args.bitrate, ) ","wordCount":"594","inLanguage":"en","datePublished":"2025-05-20T22:17:40+08:00","dateModified":"2025-05-20T22:17:40+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://tnzzz.top/posts/%E6%95%99%E7%A8%8B/ffmpeg-%E5%B0%86%E8%A7%86%E9%A2%91%E8%BD%AC%E7%A0%81%E8%87%B3-h265-%E7%BC%96%E7%A0%81/"},"publisher":{"@type":"Organization","name":"明天吃什么？","logo":{"@type":"ImageObject","url":"https://tnzzz.top/favicon.ico"}}}</script></head><body id=top><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "ccaaab867b5e4fe590baed8e233a2d10"}'></script><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tnzzz.top/ accesskey=h title="明天吃什么？ (Alt + H)">明天吃什么？</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://tnzzz.top/categories/ title=分类><span>分类</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">ffmpeg 将视频转码至 h265 编码</h1><div class=post-meta><span title='2025-05-20 22:17:40 +0800 +0800'>May 20, 2025</span></div></header><div class=post-content><h3 id=ffmpeg-简介>ffmpeg 简介<a hidden class=anchor aria-hidden=true href=#ffmpeg-简介>#</a></h3><p>FFmpeg是一个开源的音视频处理工具，支持录制、转换数字音频、视频，并能将其转化为流。它包含了一个完整的解决方案，能够处理几乎所有的音视频格式。</p><p>FFmpeg的核心是libavcodec库，它提供了多种音视频编解码器，支持从简单的音频转码到复杂的视频处理任务。FFmpeg还提供了丰富的命令行工具，用户可以通过命令行轻松实现音视频的转换、剪辑、合并等操作。</p><p>FFmpeg的跨平台特性使其能够在Linux、Windows和macOS等多种操作系统上运行。它的强大功能和灵活性使其成为音视频处理领域的事实标准。</p><p><a href=https://ffmpeg.org/>Source</a></p><h3 id=必要条件>必要条件<a hidden class=anchor aria-hidden=true href=#必要条件>#</a></h3><ul><li>安装FFmpeg：确保你的系统上已经安装了FFmpeg。</li></ul><h3 id=转码命令>转码命令<a hidden class=anchor aria-hidden=true href=#转码命令>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Intel QuickSync (hevc_qsv)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 参数:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   -global_quality: 1–51（类似 CRF，数值越大质量越低，文件越小，默认23）</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   -preset: ultrafast | fast | medium | slow | slower | veryslow（速度↑/压缩率↓，默认medium）</span>
</span></span><span style=display:flex><span>ffmpeg -y -i input.mp4 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -c:v hevc_qsv -global_quality <span style=color:#ae81ff>23</span> -preset medium <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -c:a copy -c:s copy <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  output_h265_intel.mp4
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># AMD AMF (hevc_amf)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 参数:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   -qp:       0–51（质量参数，数值越大压缩越强，默认23）</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   -quality:  speed | balanced | quality（speed=最快最低质；balanced=中；quality=最高质，默认balanced）</span>
</span></span><span style=display:flex><span>ffmpeg -y -i input.mp4 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -c:v hevc_amf -rc cqp -qp <span style=color:#ae81ff>23</span> -quality balanced <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -c:a copy -c:s copy <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  output_h265_amd.mp4
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># NVIDIA NVENC (hevc_nvenc)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 参数:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   -cq:     0–51（质量参数，数值越大质量越低，文件越小，默认23）</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   -preset: ultrafast | fast | medium | slow | slower | veryslow（同x265预设，默认medium）</span>
</span></span><span style=display:flex><span>ffmpeg -y -i input.mp4 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -c:v hevc_nvenc -cq <span style=color:#ae81ff>23</span> -preset medium <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -c:a copy -c:s copy <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  output_h265_nvidia.mp4
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 软件 x265 (libx265)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 参数:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   -crf:    0–51（数值越大压缩越强，默认23）</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   -preset: ultrafast | fast | medium | slow | slower | veryslow（速度↑/压缩率↓，默认medium）</span>
</span></span><span style=display:flex><span>ffmpeg -y -i input.mp4 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -c:v libx265 -crf <span style=color:#ae81ff>23</span> -preset medium <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -c:a copy -c:s copy <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  output_h265_x265.mp4
</span></span></code></pre></div><h3 id=python-脚本>Python 脚本<a hidden class=anchor aria-hidden=true href=#python-脚本>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env python3</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -*- coding: utf-8 -*-</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>将视频文件转码为H.265编码。
</span></span></span><span style=display:flex><span><span style=color:#e6db74>用法: python convert_to_h265.py &lt;视频文件路径&gt; [--intel] [--amd] [--nvidia]
</span></span></span><span style=display:flex><span><span style=color:#e6db74>使用 --intel 参数启用 Intel QuickSync 硬件加速
</span></span></span><span style=display:flex><span><span style=color:#e6db74>使用 --amd 参数启用 AMD AMF 硬件加速
</span></span></span><span style=display:flex><span><span style=color:#e6db74>使用 --nvidia 参数启用 NVIDIA NVENC 硬件加速
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> argparse
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> os
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> subprocess
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>convert_to_h265</span>(
</span></span><span style=display:flex><span>    input_file,
</span></span><span style=display:flex><span>    use_intel<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>,
</span></span><span style=display:flex><span>    use_amd<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>,
</span></span><span style=display:flex><span>    use_nvidia<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>,
</span></span><span style=display:flex><span>    crf<span style=color:#f92672>=</span><span style=color:#ae81ff>23</span>,
</span></span><span style=display:flex><span>    preset<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;medium&#34;</span>,
</span></span><span style=display:flex><span>    bitrate<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>,
</span></span><span style=display:flex><span>):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    使用ffmpeg将视频转码为H.265格式
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    参数:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        input_file: 输入视频文件路径
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        use_intel: 是否使用Intel QuickSync硬件加速
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        use_amd: 是否使用AMD AMF硬件加速
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        use_nvidia: 是否使用NVIDIA NVENC硬件加速
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 检查文件是否存在</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>isfile(input_file):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;错误: 文件不存在 - </span><span style=color:#e6db74>{</span>input_file<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 构建输出文件路径</span>
</span></span><span style=display:flex><span>    file_dir <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>dirname(input_file)
</span></span><span style=display:flex><span>    file_name, file_ext <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>splitext(os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>basename(input_file))
</span></span><span style=display:flex><span>    output_file <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(file_dir, <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>file_name<span style=color:#e6db74>}</span><span style=color:#e6db74>_h265</span><span style=color:#e6db74>{</span>file_ext<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 将 Windows 路径反斜杠改为正斜杠，避免 \0 被误识别</span>
</span></span><span style=display:flex><span>    input_file <span style=color:#f92672>=</span> input_file<span style=color:#f92672>.</span>replace(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>&#34;</span>, <span style=color:#e6db74>&#34;/&#34;</span>)
</span></span><span style=display:flex><span>    output_file <span style=color:#f92672>=</span> output_file<span style=color:#f92672>.</span>replace(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>&#34;</span>, <span style=color:#e6db74>&#34;/&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 构建 ffmpeg 命令</span>
</span></span><span style=display:flex><span>    ffmpeg_cmd <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;ffmpeg&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;-y&#34;</span>,  <span style=color:#75715e># 如果目标已存在则强制覆盖</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;-i&#34;</span>,
</span></span><span style=display:flex><span>        input_file,
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 硬件／软件编码选择</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> use_intel:
</span></span><span style=display:flex><span>        ffmpeg_cmd<span style=color:#f92672>.</span>extend(
</span></span><span style=display:flex><span>            [
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;-c:v&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;hevc_qsv&#34;</span>,  <span style=color:#75715e># Intel QuickSync HEVC/H.265编码器</span>
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;-global_quality&#34;</span>,
</span></span><span style=display:flex><span>                str(crf),  <span style=color:#75715e># QSV 对应的质量参数</span>
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;-preset&#34;</span>,
</span></span><span style=display:flex><span>                preset,
</span></span><span style=display:flex><span>            ]
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> use_amd:
</span></span><span style=display:flex><span>        <span style=color:#75715e># 将 --preset 映射到 AMF 的 quality 参数</span>
</span></span><span style=display:flex><span>        amf_quality <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;ultrafast&#34;</span>: <span style=color:#e6db74>&#34;speed&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;fast&#34;</span>: <span style=color:#e6db74>&#34;speed&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;medium&#34;</span>: <span style=color:#e6db74>&#34;balanced&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;slow&#34;</span>: <span style=color:#e6db74>&#34;quality&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;slower&#34;</span>: <span style=color:#e6db74>&#34;quality&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;veryslow&#34;</span>: <span style=color:#e6db74>&#34;quality&#34;</span>,
</span></span><span style=display:flex><span>        }<span style=color:#f92672>.</span>get(preset, <span style=color:#e6db74>&#34;balanced&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ffmpeg_cmd<span style=color:#f92672>.</span>extend(
</span></span><span style=display:flex><span>            [
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;-c:v&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;hevc_amf&#34;</span>,  <span style=color:#75715e># AMD HEVC/H.265编码器</span>
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;-rc&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;cqp&#34;</span>,  <span style=color:#75715e># AMF 使用 CQP 模式</span>
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;-qp&#34;</span>,
</span></span><span style=display:flex><span>                str(crf),  <span style=color:#75715e># AMF 的质量参数</span>
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;-quality&#34;</span>,
</span></span><span style=display:flex><span>                amf_quality,  <span style=color:#75715e># AMF 支持的 quality 选项</span>
</span></span><span style=display:flex><span>            ]
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> use_nvidia:
</span></span><span style=display:flex><span>        ffmpeg_cmd<span style=color:#f92672>.</span>extend(
</span></span><span style=display:flex><span>            [
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;-c:v&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;hevc_nvenc&#34;</span>,  <span style=color:#75715e># NVIDIA NVENC H.265编码器</span>
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;-cq&#34;</span>,
</span></span><span style=display:flex><span>                str(crf),  <span style=color:#75715e># NVENC 的质量参数</span>
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;-preset&#34;</span>,
</span></span><span style=display:flex><span>                preset,
</span></span><span style=display:flex><span>            ]
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># 软件 x265 编码</span>
</span></span><span style=display:flex><span>        ffmpeg_cmd<span style=color:#f92672>.</span>extend(
</span></span><span style=display:flex><span>            [
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;-c:v&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;libx265&#34;</span>,  <span style=color:#75715e># 软件x265编码器</span>
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;-crf&#34;</span>,
</span></span><span style=display:flex><span>                str(crf),
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;-preset&#34;</span>,
</span></span><span style=display:flex><span>                preset,
</span></span><span style=display:flex><span>            ]
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 如果指定了固定码率，则覆盖质量参数</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> bitrate:
</span></span><span style=display:flex><span>        ffmpeg_cmd<span style=color:#f92672>.</span>extend([<span style=color:#e6db74>&#34;-b:v&#34;</span>, bitrate])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 添加通用的编码参数</span>
</span></span><span style=display:flex><span>    ffmpeg_cmd<span style=color:#f92672>.</span>extend(
</span></span><span style=display:flex><span>        [
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;-c:a&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;copy&#34;</span>,  <span style=color:#75715e># 复制音频流</span>
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;-c:s&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;copy&#34;</span>,  <span style=color:#75715e># 复制字幕流 (如果有)</span>
</span></span><span style=display:flex><span>            output_file,
</span></span><span style=display:flex><span>        ]
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;正在转码: </span><span style=color:#e6db74>{</span>input_file<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;输出文件: </span><span style=color:#e6db74>{</span>output_file<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;转码中，请稍候...&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 执行ffmpeg命令</span>
</span></span><span style=display:flex><span>        process <span style=color:#f92672>=</span> subprocess<span style=color:#f92672>.</span>Popen(
</span></span><span style=display:flex><span>            ffmpeg_cmd,
</span></span><span style=display:flex><span>            stdout<span style=color:#f92672>=</span>subprocess<span style=color:#f92672>.</span>PIPE,
</span></span><span style=display:flex><span>            stderr<span style=color:#f92672>=</span>subprocess<span style=color:#f92672>.</span>STDOUT,
</span></span><span style=display:flex><span>            universal_newlines<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>,
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 安全地处理并显示进度信息</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> process<span style=color:#f92672>.</span>stdout:  <span style=color:#75715e># 确保stdout不是None</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> line <span style=color:#f92672>in</span> process<span style=color:#f92672>.</span>stdout:
</span></span><span style=display:flex><span>                <span style=color:#75715e># 仅显示包含关键字的行以减少输出量</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;frame=&#34;</span> <span style=color:#f92672>in</span> line <span style=color:#f92672>or</span> <span style=color:#e6db74>&#34;speed=&#34;</span> <span style=color:#f92672>in</span> line <span style=color:#f92672>or</span> <span style=color:#e6db74>&#34;error&#34;</span> <span style=color:#f92672>in</span> line<span style=color:#f92672>.</span>lower():
</span></span><span style=display:flex><span>                    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\r</span><span style=color:#e6db74>{</span>line<span style=color:#f92672>.</span>strip()<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>, end<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            <span style=color:#75715e># 如果无法获取输出流，提供一个替代方案</span>
</span></span><span style=display:flex><span>            print(<span style=color:#e6db74>&#34;正在处理中，请等待...&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 等待进程完成</span>
</span></span><span style=display:flex><span>        return_code <span style=color:#f92672>=</span> process<span style=color:#f92672>.</span>wait()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> return_code <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n\n</span><span style=color:#e6db74>转码完成！输出文件: </span><span style=color:#e6db74>{</span>output_file<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>            print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;原始文件大小: </span><span style=color:#e6db74>{</span>os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>getsize(input_file) <span style=color:#f92672>/</span> (<span style=color:#ae81ff>1024</span><span style=color:#f92672>*</span><span style=color:#ae81ff>1024</span>)<span style=color:#e6db74>:</span><span style=color:#e6db74>.2f</span><span style=color:#e6db74>}</span><span style=color:#e6db74> MB&#34;</span>)
</span></span><span style=display:flex><span>            print(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;转码后文件大小: </span><span style=color:#e6db74>{</span>os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>getsize(output_file) <span style=color:#f92672>/</span> (<span style=color:#ae81ff>1024</span><span style=color:#f92672>*</span><span style=color:#ae81ff>1024</span>)<span style=color:#e6db74>:</span><span style=color:#e6db74>.2f</span><span style=color:#e6db74>}</span><span style=color:#e6db74> MB&#34;</span>
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>转码失败，ffmpeg返回错误代码: </span><span style=color:#e6db74>{</span>return_code<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>FileNotFoundError</span>:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;错误: 找不到ffmpeg。请确保ffmpeg已安装并添加到系统PATH中。&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>Exception</span> <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;发生错误: </span><span style=color:#e6db74>{</span>str(e)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;__main__&#34;</span>:
</span></span><span style=display:flex><span>    parser <span style=color:#f92672>=</span> argparse<span style=color:#f92672>.</span>ArgumentParser(description<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;将视频转码为H.265格式&#34;</span>)
</span></span><span style=display:flex><span>    parser<span style=color:#f92672>.</span>add_argument(<span style=color:#e6db74>&#34;input_file&#34;</span>, help<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;输入视频文件路径&#34;</span>)
</span></span><span style=display:flex><span>    parser<span style=color:#f92672>.</span>add_argument(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;--intel&#34;</span>,
</span></span><span style=display:flex><span>        action<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;store_true&#34;</span>,
</span></span><span style=display:flex><span>        help<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;使用 Intel QuickSync硬件加速&#34;</span>,
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    parser<span style=color:#f92672>.</span>add_argument(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;--amd&#34;</span>,
</span></span><span style=display:flex><span>        action<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;store_true&#34;</span>,
</span></span><span style=display:flex><span>        help<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;使用 AMD GPU 硬件加速&#34;</span>,
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    parser<span style=color:#f92672>.</span>add_argument(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;--nvidia&#34;</span>,
</span></span><span style=display:flex><span>        action<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;store_true&#34;</span>,
</span></span><span style=display:flex><span>        help<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;使用 NVIDIA NVENC 硬件加速&#34;</span>,
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 新增质量/码率可调参数</span>
</span></span><span style=display:flex><span>    parser<span style=color:#f92672>.</span>add_argument(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;--crf&#34;</span>,
</span></span><span style=display:flex><span>        type<span style=color:#f92672>=</span>int,
</span></span><span style=display:flex><span>        default<span style=color:#f92672>=</span><span style=color:#ae81ff>23</span>,
</span></span><span style=display:flex><span>        help<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;质量参数（CRF或等效值，数值越大文件越小）&#34;</span>,
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    parser<span style=color:#f92672>.</span>add_argument(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;--preset&#34;</span>,
</span></span><span style=display:flex><span>        default<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;medium&#34;</span>,
</span></span><span style=display:flex><span>        choices<span style=color:#f92672>=</span>[
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;ultrafast&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;fast&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;medium&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;slow&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;slower&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;veryslow&#34;</span>,
</span></span><span style=display:flex><span>        ],
</span></span><span style=display:flex><span>        help<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;编码preset&#34;</span>,
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    parser<span style=color:#f92672>.</span>add_argument(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;--bitrate&#34;</span>,
</span></span><span style=display:flex><span>        help<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;目标码率，如2000k，优先于CRF/质量参数&#34;</span>,
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    args <span style=color:#f92672>=</span> parser<span style=color:#f92672>.</span>parse_args()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> sum(bool(x) <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> (args<span style=color:#f92672>.</span>intel, args<span style=color:#f92672>.</span>amd, args<span style=color:#f92672>.</span>nvidia)) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;错误: 只能指定一个硬件加速选项&#34;</span>)
</span></span><span style=display:flex><span>        sys<span style=color:#f92672>.</span>exit(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    convert_to_h265(
</span></span><span style=display:flex><span>        args<span style=color:#f92672>.</span>input_file,
</span></span><span style=display:flex><span>        use_intel<span style=color:#f92672>=</span>args<span style=color:#f92672>.</span>intel,
</span></span><span style=display:flex><span>        use_amd<span style=color:#f92672>=</span>args<span style=color:#f92672>.</span>amd,
</span></span><span style=display:flex><span>        use_nvidia<span style=color:#f92672>=</span>args<span style=color:#f92672>.</span>nvidia,
</span></span><span style=display:flex><span>        crf<span style=color:#f92672>=</span>args<span style=color:#f92672>.</span>crf,
</span></span><span style=display:flex><span>        preset<span style=color:#f92672>=</span>args<span style=color:#f92672>.</span>preset,
</span></span><span style=display:flex><span>        bitrate<span style=color:#f92672>=</span>args<span style=color:#f92672>.</span>bitrate,
</span></span><span style=display:flex><span>    )
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://tnzzz.top/>明天吃什么？</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a> &
<a href=https://beian.miit.gov.cn/#/Integrated/index>粤ICP备2022076439号</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>